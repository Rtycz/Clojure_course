; comment 
; (comment ...)
; (def a [1 2 3]) 					; определение

; "text" - строка
; /c - символ c
; (get "string" N) - Возвращает N-ый символ строки "string"
; (str "s1" "s2") - конкатинация				в перечислении пробел заменяет ","
; (subs "Hello World" 0 5) - Возвращает Hello
; (clojure.string/join '(1 2 3)) - соединяет в строку эл-ты списка
; (clojure.string/join ", " '(1 2 3)) - применяет первый аргумент после каждого эл-та из второго
; (clojure.string/split-lines "1\n2\n3") - превращает большую строку в массив маленьких => ["1" "2" "3"]
; (clojure.string/reverse "hello") - реверсирует строку
; (clojure.string/index-of "hello world" "h") - ищет первое вхождение второй подстроки в первую строку; если такого нет то возвращает Nil
; (clojure.string/last-index-of "hello world, hello" "hello") - ищет последнее вхождение в строку
; (= "hello world" (clojure.string/trim "  \nhello world \t \n"))
; (char? \c) - проверка на чаровость => 0/1; строку из 1 символа нельзя так проверить
; (string? "bob") - проверка на стринговость 
; (clojure.string/blank? "") - проверка строки на пустоту
; (char ascii) - перевод чего то в строку
; (char \unicode) - перевод чего то в строку \tab \space
; (count "aaa") - возвращает кол-во эл-тов строки

; :keyword - ключи в clojure 
; :keyword - связывает то что вместо keyword и какое то численное значение которое генерируется автоматически
; (keyword ...)	- связывает то что вместо keyword и какое то численное значение которое генерируется автоматически

; (doc ...) - выводит документацию о объекте
; (source ...) - выдает исходный код			(source +)

; тут команды которые используются для каждой коллекции
; (count '(dracula dooku chocula)) - возвращает кол-во эл-тов коллекции

; '(a b c) - список 
;	list (a b c)	- составление списка = '(a b с)
; (cons :a '(:b :c :d :e)) - возвращает новую последовательность где а - первый элемент - construction
;	(conj '(:a :b :c :d) :e) - возвращает новую последовательность где e - первый элемент - conjoining, 
; в документации написано что добавление может случиться  в любое место в зависимости от типа 
; (peek '(:a :b :c :d :e)) - возвращает первый ЭЛЕМЕНТ списка
; (pop '(:a :b :c :d :e)) - возвращает СПИСОК с элементами кроме первого. если попнуть пустой список то будет ошибка

; [a b c] массив
; (vector a b c) массив можно обратиться по индексу
; (conj '[:a :b :c :d] :e) - возвращает новый массив где e - последний элемент - conjoining
; (cons :a [:b :c :d :e]) - возвращает новый массив где a - первый элемент - conjoining
; (subvec [:peanut :butter :and :jelly] 1 3) - возвращает новый массив с элементами с 1 включительно по 3 не включительно

; #{a b c} - Множество - 
; чтобы использовать сет как человек надо прописать в консольке (require '[clojure.set :as set])
; (hash-set a b c) сохраняет элементы можно хранить разные элементы по типу
; (sorted-set a b c) сохраняет порядок
; (set [1 2 3]) = (set '(1 2 3)) - на вход set подается массив или список
; (= #{1 2 3 4 5} (clojure.set/union #{1 2 3 4} #{2 3 5})) - union - Объединяет два множества. повторяющиеся эл-ты исключаются
; (= #{2 3} (clojure.set/intersection #{1 2 3 4} #{2 3 5})) - intersection - вовзращает пересечение двух множеств
; (= #{1 4} (set/difference #{1 2 3 4 5} #{2 3 5})) - differece - возвращает результат вычитания второго мн-ва из первого
; (merge-with + {:a 1 :b 1} {:b 1 :c 3})) - обьединяет с учетом повторяющихся
; (sort (keys { 2014 "Sochi" 2018 "PyeongChang" 2010 "Vancouver"})) - сортирует ключи по возрастанию и делает ил них список???!
; (sort (vals { 2010 "Vancouver" 2014 "Sochi" 2018 "PyeongChang"})) - сортирует значения по 
;
; {key1 value1, key2 value2, ...} - map каждому ключу ставится в соответствие значение value может быть и строкой в т.ч.
; (hash-map ...) - хранит содержимое - дерево - порядок неважен
; (sorted-map ...) - хранит соддержимое с порядком
; (get {:a 1 :b 2} :b) - получает значение ключа :b, если не находит ключ то возвратит nil
; (= 1 ({:a 1 :b 2} :a)) -- все это получает значение пары ключа А
; (= 1 (:a {:a 1 :b 2})) 
; (get {:a 1 :b 2} :c :key-not-found) - ищет вхождение ключа иначе возвращает ключ из конца
; (assoc {1 "January"} 2 "February") - расширит map
; (merge {:a 1 :b 2} {:c 3}) - делает то же самое, возможно один соединяет другой создает
; (dissoc {1 "January" 2 "February"} 2) - убирает из map по ключу 
;
; эти 4 структуры данных - коллекции

; навигация в структурах 
; (first [1 2 3]) - первый элемент
; (last a) - послений элемент
; (rest ...) - все кроме первого. Если рестнуть пустой список то ошибки не будет
; (nth ... n) - n-ый элемент


; если коллекция сконструирована то она не будет изменена - иммутабельность
; (conj ...) - соединение списков 
; (disj ...) - удаление эл-та из коллекции. элемент не удаляется из коллекции, а создается информация что в коллекции произошло удаление
; 
; можно создать пространство имен
; (ns ) если есть пр-во он использует если нет то создает ---------------------Непонятно как работает и неплохо бы почитать
; 
; (let [a 2, b 3] соединение какого то значения и переменной типа локальной переменной для потока
;	(+ a b)) 
; = 5
; 
; (binding [a 2, b 3]) - перекрывает значение глобальной переменной для потока забиндить можно на значение но на выражение
; с какой то версии кложа перекрываемые переменные надо объявлять динамической (def ^:dynamic a [1 2 3])
; 
; (apply функция коллекция) (apply + [1 2 3])=(+ [1 2 3])
; 
; как задать функцию
; (defn f [ p1 v1, p2 v2]								анонимная функция + связывание с переменной чтоб меньше скобок
; .
; .
; .
; )

; примеры:
; (defn multiply-by-ten [n]
;  (* 10 n))

; (defn square [n] (* n n))

; (= 10 ((fn [n] (* 5 n)) 2))

; (= 60 (#(* 15 %) 4))

; (= 15 (#(+ %1 %2 %3) 4 5 6))

; (= "AACC" (#(str "AA" %2) "bb" "CC"))
; 
; #(%1 %2) анонимная функция с именованными параметрами
; (map #(+ %1 1) '(1 2 3)) - берет функцию у которой один аргумент применяет +1 к каждому элементу коллекции и возвращает в ноую коллекцию 
; = 2 3 4 
; (map #((if %1>2 0 %1) '(1 2 3))
; 
; функция фильтр пробегает по коллекцию и берет элементы которые удовлетворяют условию
; (filter #(> %1 0) '(-1 0 1)) = 1
; 
; логические функции обозначают (ф-я? арг) => 0/1
; (odd? ) - нечетные 
; (even? ) - четные
; 
; Логические выражения
; (and ... ... ... ...)
; (or ... ... ...)
;
; (reduce * [1 2 3]) = 1*2*3 сжимает в одно число 
; (reduce #((if (= %2 "a") %1 (str %1 %2)) '("a" "b" "c")) - сложить четные эл-ты последовательности

;(reduce 																																												
;			(fn [primes number] 
;				(if (some zero? (map (partial mod number) primes))
;			 primes 
;			 (conj primes number)));  - список простых чисел из 1-1000
;		[2] 
;		(take 1000 (iterate inc 3))); - берет 1000 элементов из ленивой послед-ти 3,4,...

; (reduce (fn [primes number] (if (some zero? (map (partial mod number) primes)) primes (conj primes number))) [2] (take 1000 (iterate inc 3)))

; 'symbol = (symbol "symbol") это создание символа символ это имя - терма языка
; сивол и ключ это не одно и то же

; исключения записываются в виде:
; (try
;          (pop '())																										то что делаем
;          (catch IllegalStateException e    	непонятная штука, если заменить е то ничего не меняется
;            "No dice!"))																					то что вылазит в случе ошибки